# TaskWall v2.0 技术实现文档

## 🏗️ 架构概览

TaskWall v2.0 采用前后端分离架构，集成多项AI功能，实现智能化任务管理。

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端 (Vue 3)   │◄──►│  后端 (FastAPI)  │◄──►│   AI服务 (Gemini) │
│   - 组件化设计    │    │   - RESTful API │    │   - 自然语言处理  │
│   - 状态管理     │    │   - 数据库操作   │    │   - 智能分析     │
│   - 实时交互     │    │   - AI集成      │    │   - 内容生成     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## 🧠 AI功能技术栈

### 1. AI助手笔 (`/ai` 命令)

**技术实现**:
- **前端**: Vue组合式API + 事件监听
- **后端**: FastAPI端点 + Gemini Pro API
- **算法**: 基于Prompt Engineering的指令处理

**核心代码结构**:
```typescript
// 前端: AIAssistantPrompt.vue
interface AIAssistantCommand {
  id: string;          // 'rewrite', 'add-emoji', 'summarize', 'make-subtasks'
  label: string;       // 显示名称
  icon: string;        // 图标
  description: string; // 描述
}

// 后端: ai_client.py
def execute_assistant_command(command: str, content: str, context: str) -> str:
    prompts = {
        'rewrite': "重写以下文本使其更清晰简洁...",
        'add-emoji': "为以下文本添加合适的表情符号...",
        'summarize': "创建以下文本的简洁摘要...",
        'make-subtasks': "将以下任务分解为3-5个子任务..."
    }
```

**关键特性**:
- 支持4种AI命令模式
- 智能上下文理解
- 降级到规则引擎作为备选

### 2. 全局模糊搜索

**技术实现**:
- **搜索算法**: 前端实时文本匹配
- **UI组件**: 模态弹窗 + 键盘导航
- **性能优化**: 防抖输入 + 虚拟滚动

**核心代码结构**:
```typescript
// 搜索逻辑
const searchResults = computed(() => {
  if (!searchQuery.value.trim()) return []
  
  const query = searchQuery.value.toLowerCase()
  return taskStore.tasks.filter(task => 
    task.title.toLowerCase().includes(query) ||
    task.description.toLowerCase().includes(query)
  )
})

// 高亮显示
const highlightText = (text: string) => {
  const regex = new RegExp(`(${searchQuery.value})`, 'gi')
  return text.replace(regex, '<mark>$1</mark>')
}
```

**快捷键实现**:
```typescript
// 全局快捷键监听
document.addEventListener('keydown', (event) => {
  if (event.shiftKey && (event.metaKey || event.ctrlKey) && event.key === 'k') {
    event.preventDefault()
    showGlobalSearch.value = true
  }
})
```

### 3. 自动子任务拆分

**技术实现**:
- **AI模型**: Gemini Pro结构化输出
- **数据处理**: JSON解析 + 错误处理
- **关系建立**: 自动创建父子依赖

**核心算法**:
```python
def generate_subtasks(parent_title: str, parent_description: str, max_subtasks: int = 5):
    prompt = f"""
    生成{max_subtasks}个子任务，要求：
    - 每个子任务1-4小时可完成
    - 具体可执行
    - 有助于完成父任务
    
    父任务: {parent_title}
    描述: {parent_description}
    
    返回JSON格式：
    [
      {{"title": "具体任务名", "description": "详细描述", "urgency": 2}}
    ]
    """
    
    response = gemini_model.generate_content(prompt)
    return json.loads(response.text)
```

### 4. 相似任务检测

**技术实现**:
- **相似度算法**: 文本序列匹配 + 词汇重叠
- **阈值控制**: 可配置相似度阈值(默认85%)
- **交互设计**: 非侵入式提示弹窗

**核心算法**:
```python
def calculate_similarity(text1: str, text2: str) -> float:
    # 1. 序列相似度
    seq_similarity = SequenceMatcher(None, text1, text2).ratio()
    
    # 2. 词汇重叠度
    words1 = set(re.findall(r'\w+', text1.lower()))
    words2 = set(re.findall(r'\w+', text2.lower()))
    word_overlap = len(words1 & words2) / len(words1 | words2)
    
    # 3. 标题权重
    title_similarity = calculate_title_similarity(text1, text2) * 1.5
    
    return (seq_similarity + word_overlap + title_similarity) / 3
```

### 5. 工时负载预警

**技术实现**:
- **工时估算**: 基于优先级的默认估算 + 用户调整
- **负载计算**: 实时统计当日任务工时
- **可视化**: 进度条 + 颜色指示器

**估算规则**:
```python
# 默认工时估算映射
HOUR_MAPPING = {
    0: 8.0,  # P0 - 8小时
    1: 6.0,  # P1 - 6小时  
    2: 4.0,  # P2 - 4小时
    3: 2.0,  # P3 - 2小时
    4: 1.0   # P4 - 1小时
}

def calculate_workload(tasks: List[Task], target_date: date) -> WorkloadAnalysis:
    daily_tasks = filter_tasks_by_date(tasks, target_date)
    total_hours = sum(estimate_hours(task) for task in daily_tasks)
    capacity_hours = 6.0  # 默认日工作时长
    
    workload_percentage = (total_hours / capacity_hours) * 100
    conflict_level = get_conflict_level(workload_percentage)
    
    return WorkloadAnalysis(
        total_hours=total_hours,
        workload_percentage=workload_percentage,
        conflict_level=conflict_level
    )
```

### 6. 一键周报生成

**技术实现**:
- **数据收集**: 自动筛选7天内任务变更
- **AI生成**: 结构化Prompt + Markdown输出
- **导出功能**: 支持复制/下载/第三方集成

**生成逻辑**:
```python
def generate_weekly_report(tasks: List[Dict], start_date: str, end_date: str) -> str:
    # 分类任务
    completed_tasks = [task for task in tasks if task.get('status') == 'completed']
    in_progress_tasks = [task for task in tasks if task.get('status') == 'in_progress']
    pending_tasks = [task for task in tasks if task.get('status') == 'pending']
    
    prompt = f"""
    生成{start_date}到{end_date}的专业周报，包含：
    1. 执行摘要 - 本周工作概览
    2. 已完成任务 ({len(completed_tasks)}) - 详细列表
    3. 进行中任务 ({len(in_progress_tasks)}) - 当前状态
    4. 计划任务 ({len(pending_tasks)}) - 下周安排
    5. 风险与阻塞 - 识别问题和建议
    
    任务数据: {tasks}
    """
    
    return ai_model.generate_content(prompt).text
```

### 7. 情绪风险雷达

**技术实现**:
- **关键词检测**: 预定义风险词汇库
- **情绪分析**: 基于规则的情绪评分
- **风险评级**: 多维度风险评分算法

**风险检测算法**:
```python
RISK_KEYWORDS = {
    "delay": ["延期", "推迟", "拖延", "超期", "deadline", "late"],
    "blocked": ["卡住", "阻塞", "等待", "依赖", "blocked", "stuck"],
    "complexity": ["复杂", "困难", "challenging", "difficult", "unclear"],
    "emotional_stress": ["压力", "紧急", "焦虑", "stress", "urgent", "pressure"]
}

def analyze_task_risk(task: Dict) -> RiskAnalysis:
    text = f"{task.get('title', '')} {task.get('description', '')}"
    risk_score = 0
    risk_categories = []
    
    # 关键词匹配
    for category, keywords in RISK_KEYWORDS.items():
        if any(keyword in text.lower() for keyword in keywords):
            risk_categories.append(category)
            risk_score += get_category_weight(category)
    
    # 优先级加权
    if task.get('urgency', 2) <= 1:
        risk_score += 2
    
    # 任务年龄加权
    days_old = calculate_task_age(task)
    if days_old > 30:
        risk_score += 1
        risk_categories.append("stale")
    
    return RiskAnalysis(
        risk_score=risk_score,
        risk_level=determine_risk_level(risk_score),
        risk_categories=risk_categories,
        recommendations=generate_recommendations(risk_categories)
    )
```

### 8. 主题岛聚类视图

**技术实现**:
- **文本处理**: 中英文关键词提取
- **聚类算法**: 简化版HDBSCAN实现
- **可视化**: 动态岛屿布局 + 颜色编码

**聚类算法**:
```python
def create_theme_islands(tasks: List[Dict]) -> Dict:
    # 提取关键词
    all_keywords = []
    task_keywords = {}
    
    for task in tasks:
        text = f"{task.get('title', '')} {task.get('description', '')}"
        keywords = extract_meaningful_keywords(text)
        task_keywords[task.get('id')] = keywords
        all_keywords.extend(keywords)
    
    # 找出高频主题词
    keyword_counts = Counter(all_keywords)
    top_themes = [word for word, count in keyword_counts.most_common(8) if count > 1]
    
    # 基于主题创建岛屿
    islands = []
    used_tasks = set()
    
    for i, theme in enumerate(top_themes):
        island_tasks = []
        for task in tasks:
            if task.get('id') in used_tasks:
                continue
            if theme in task_keywords.get(task.get('id'), []):
                island_tasks.append(task)
                used_tasks.add(task.get('id'))
        
        if island_tasks:
            islands.append({
                "id": i + 1,
                "name": f"{theme.title()} 相关",
                "theme": theme,
                "color": ISLAND_COLORS[i % len(ISLAND_COLORS)],
                "tasks": island_tasks
            })
    
    return {"islands": islands, "stats": calculate_stats(islands)}
```

## 📁 项目结构

```
TaskWall/
├── backend/                    # FastAPI后端
│   ├── app/
│   │   ├── main.py            # 应用入口点
│   │   ├── models.py          # 数据模型
│   │   ├── schemas.py         # API模式
│   │   ├── crud.py            # 数据库操作
│   │   └── utils/
│   │       ├── ai_client.py   # AI客户端
│   │       ├── backup.py      # 备份服务
│   │       ├── export.py      # 导出服务
│   │       └── ocr.py         # OCR处理
│   └── requirements.txt       # Python依赖
├── frontend/                   # Vue 3前端
│   ├── src/
│   │   ├── components/        # 组件库
│   │   │   ├── AIAssistantPrompt.vue      # AI助手弹窗
│   │   │   ├── GlobalSearch.vue           # 全局搜索
│   │   │   ├── WorkloadSidebar.vue        # 工时侧栏
│   │   │   ├── SimilarTaskDialog.vue      # 相似任务对话框
│   │   │   ├── RiskRadar.vue              # 风险雷达
│   │   │   └── TaskCard.vue               # 任务卡片
│   │   ├── composables/       # 组合式函数
│   │   │   ├── useAIAssistant.ts          # AI助手逻辑
│   │   │   ├── useSimilarityDetection.ts  # 相似度检测
│   │   │   └── useKeyboard.ts             # 快捷键管理
│   │   ├── stores/            # 状态管理
│   │   │   ├── tasks.ts       # 任务状态
│   │   │   └── settings.ts    # 设置状态
│   │   └── pages/
│   │       └── Home.vue       # 主页面
│   └── package.json           # Node依赖
├── data/                       # 数据目录
│   ├── taskwall.db            # SQLite数据库
│   └── backup/                # 备份文件
├── start.sh                    # 启动脚本
├── v2.0-功能演示.md             # 功能演示文档
└── 技术实现文档.md              # 本文档
```

## 🔧 关键技术决策

### 1. AI服务选择
- **主选**: Google Gemini Pro - 优秀的中文支持和结构化输出
- **备选**: 本地规则引擎 - 确保在无API密钥时仍可使用

### 2. 前端架构
- **框架**: Vue 3 + Composition API - 现代化响应式设计
- **状态管理**: Pinia - 轻量级且类型安全
- **UI库**: Element Plus - 丰富的组件生态

### 3. 搜索策略
- **实时搜索**: 前端内存搜索，性能优秀
- **模糊匹配**: 支持部分关键词匹配
- **未来扩展**: 可接入Elasticsearch实现更强大的搜索

### 4. 数据持久化
- **数据库**: SQLite - 轻量级，易部署
- **备份策略**: 定时自动备份 + 手动导出
- **版本控制**: 任务历史记录，支持变更追踪

## 🚀 性能优化

### 1. 前端优化
- **组件懒加载**: 按需加载大型组件
- **虚拟滚动**: 处理大量任务列表
- **防抖搜索**: 避免频繁API调用
- **缓存策略**: 智能缓存AI响应结果

### 2. 后端优化
- **数据库索引**: 为常用查询字段建立索引
- **API缓存**: 缓存AI生成结果
- **批量处理**: 支持批量操作减少网络请求
- **连接池**: 优化数据库连接管理

### 3. AI调用优化
- **Prompt缓存**: 相同输入缓存结果
- **降级机制**: AI失败时使用规则引擎
- **批量调用**: 合并多个AI请求
- **超时控制**: 避免长时间等待

## 📊 可扩展性设计

### 1. 插件化架构
- AI服务可插拔，支持更换不同的LLM
- 聚类算法可配置，支持不同的聚类策略
- 导出格式可扩展，支持多种输出格式

### 2. 多租户支持
- 用户隔离的数据模型设计
- 基于角色的权限控制预留
- 团队协作功能扩展接口

### 3. 国际化准备
- 多语言文本提取
- 区域化AI模型支持
- 时区和日期格式适配

## 🔒 安全考虑

### 1. 数据隐私
- AI调用仅发送必要的任务内容
- 敏感数据本地处理，不上传云端
- 用户可选择关闭AI功能

### 2. API安全
- 输入验证和清理
- SQL注入防护
- 跨站脚本攻击防护

### 3. 密钥管理
- API密钥加密存储
- 环境变量隔离
- 密钥轮换机制

## 📈 监控与分析

### 1. 性能监控
- API响应时间追踪
- 数据库查询性能分析
- AI服务调用成功率统计

### 2. 用户行为分析
- 功能使用频率统计
- AI命令使用偏好分析
- 搜索关键词热度统计

### 3. 错误追踪
- 异常日志收集
- AI服务错误分类
- 用户反馈收集机制

---

**TaskWall v2.0** 通过精心设计的技术架构，实现了AI与传统任务管理的完美融合，为用户提供智能、高效、可靠的任务管理体验。