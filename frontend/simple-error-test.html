<!DOCTYPE html>
<html>
<head>
    <title>Console Error Test for TaskWall</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .error { background: #ffe6e6; border-color: #ff9999; }
        .success { background: #e6ffe6; border-color: #99ff99; }
        .info { background: #e6f3ff; border-color: #99ccff; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        pre { background: #f5f5f5; padding: 10px; overflow-x: auto; }
        iframe { width: 100%; height: 600px; border: 1px solid #ccc; }
    </style>
</head>
<body>
    <h1>ğŸ” TaskWall æ§åˆ¶å°é”™è¯¯æ£€æŸ¥</h1>
    
    <div class="section info">
        <h3>æµ‹è¯•çŠ¶æ€</h3>
        <div id="status">å‡†å¤‡å°±ç»ª...</div>
    </div>
    
    <div class="section">
        <h3>æ“ä½œ</h3>
        <button onclick="runTest()">ğŸš€ å¼€å§‹æµ‹è¯•</button>
        <button onclick="checkNetwork()">ğŸŒ æ£€æŸ¥ç½‘ç»œ</button>
        <button onclick="exportReport()">ğŸ“Š å¯¼å‡ºæŠ¥å‘Š</button>
    </div>
    
    <div class="section">
        <h3>å‰ç«¯åº”ç”¨ (http://localhost:3000)</h3>
        <iframe id="app-frame" src="about:blank"></iframe>
    </div>
    
    <div class="section">
        <h3>æ£€æŸ¥ç»“æœ</h3>
        <div id="results">ç­‰å¾…æ£€æŸ¥...</div>
    </div>

    <script>
        let testResults = {
            errors: [],
            warnings: [],
            networkErrors: [],
            startTime: null,
            endTime: null
        };

        function updateStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            statusDiv.innerHTML = `[${timestamp}] ${message}`;
            statusDiv.className = type;
        }

        function runTest() {
            testResults = {
                errors: [],
                warnings: [],
                networkErrors: [],
                startTime: new Date(),
                endTime: null
            };

            updateStatus('å¼€å§‹åŠ è½½åº”ç”¨å¹¶ç›‘æ§é”™è¯¯...', 'info');
            
            const iframe = document.getElementById('app-frame');
            
            iframe.onload = function() {
                try {
                    updateStatus('åº”ç”¨åŠ è½½æˆåŠŸï¼Œæ³¨å…¥ç›‘æ§è„šæœ¬...', 'success');
                    
                    // ç­‰å¾…ä¸€æ®µæ—¶é—´è®©åº”ç”¨å®Œå…¨åŠ è½½
                    setTimeout(() => {
                        checkConsoleErrors(iframe);
                    }, 2000);
                    
                } catch (error) {
                    updateStatus('æ— æ³•è®¿é—®iframeå†…å®¹: ' + error.message, 'error');
                    testResults.errors.push({
                        type: 'iframe_access_error',
                        message: error.message,
                        timestamp: new Date().toISOString()
                    });
                }
            };
            
            iframe.onerror = function() {
                updateStatus('åº”ç”¨åŠ è½½å¤±è´¥', 'error');
                testResults.errors.push({
                    type: 'app_load_error',
                    message: 'Failed to load application',
                    timestamp: new Date().toISOString()
                });
            };
            
            // åŠ è½½åº”ç”¨
            iframe.src = 'http://localhost:3000';
        }

        function checkConsoleErrors(iframe) {
            updateStatus('æ£€æŸ¥æ§åˆ¶å°é”™è¯¯ä¸­...', 'info');
            
            // å› ä¸ºåŒæºç­–ç•¥ï¼Œæˆ‘ä»¬æ— æ³•ç›´æ¥è®¿é—®iframeçš„console
            // æ‰€ä»¥æˆ‘ä»¬é€šè¿‡ç½‘ç»œè¯·æ±‚å’Œå…¶ä»–æ–¹å¼æ£€æŸ¥
            
            // æ£€æŸ¥ä¸»è¦çš„JavaScriptæ–‡ä»¶æ˜¯å¦åŠ è½½æˆåŠŸ
            const jsFiles = [
                'http://localhost:3000/src/main.ts',
                'http://localhost:3000/@vite/client'
            ];
            
            let checks = 0;
            const totalChecks = jsFiles.length;
            
            jsFiles.forEach(url => {
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            testResults.errors.push({
                                type: 'js_load_error',
                                message: `Failed to load ${url}: ${response.status} ${response.statusText}`,
                                timestamp: new Date().toISOString(),
                                url: url,
                                status: response.status
                            });
                        }
                    })
                    .catch(error => {
                        testResults.errors.push({
                            type: 'js_fetch_error',
                            message: `Network error loading ${url}: ${error.message}`,
                            timestamp: new Date().toISOString(),
                            url: url
                        });
                    })
                    .finally(() => {
                        checks++;
                        if (checks === totalChecks) {
                            setTimeout(generateReport, 1000);
                        }
                    });
            });
        }

        function checkNetwork() {
            updateStatus('æ£€æŸ¥ç½‘ç»œè¿æ¥...', 'info');
            
            const endpoints = [
                'http://localhost:3000',
                'http://localhost:8000/health',
                'http://localhost:8000/api/tasks'
            ];
            
            let completed = 0;
            const networkResults = [];
            
            endpoints.forEach(endpoint => {
                const startTime = performance.now();
                
                fetch(endpoint)
                    .then(response => {
                        const endTime = performance.now();
                        networkResults.push({
                            url: endpoint,
                            status: response.status,
                            ok: response.ok,
                            responseTime: Math.round(endTime - startTime) + 'ms'
                        });
                        
                        if (!response.ok) {
                            testResults.networkErrors.push({
                                url: endpoint,
                                status: response.status,
                                statusText: response.statusText,
                                timestamp: new Date().toISOString()
                            });
                        }
                    })
                    .catch(error => {
                        networkResults.push({
                            url: endpoint,
                            error: error.message,
                            ok: false
                        });
                        
                        testResults.networkErrors.push({
                            url: endpoint,
                            error: error.message,
                            timestamp: new Date().toISOString()
                        });
                    })
                    .finally(() => {
                        completed++;
                        if (completed === endpoints.length) {
                            displayNetworkResults(networkResults);
                        }
                    });
            });
        }

        function displayNetworkResults(results) {
            let html = '<h4>ğŸŒ ç½‘ç»œæ£€æŸ¥ç»“æœ:</h4><pre>';
            
            results.forEach(result => {
                if (result.ok) {
                    html += `âœ… ${result.url} - OK (${result.status}) ${result.responseTime}\\n`;
                } else {
                    html += `âŒ ${result.url} - ${result.error || result.status}\\n`;
                }
            });
            
            html += '</pre>';
            
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML += html;
        }

        function generateReport() {
            testResults.endTime = new Date();
            const duration = testResults.endTime - testResults.startTime;
            
            let html = `
                <h4>ğŸ“Š æ£€æŸ¥æŠ¥å‘Š</h4>
                <div class="section ${testResults.errors.length > 0 ? 'error' : 'success'}">
                    <strong>æµ‹è¯•æ—¶é—´:</strong> ${duration}ms<br>
                    <strong>JavaScripté”™è¯¯:</strong> ${testResults.errors.length}<br>
                    <strong>è­¦å‘Š:</strong> ${testResults.warnings.length}<br>
                    <strong>ç½‘ç»œé”™è¯¯:</strong> ${testResults.networkErrors.length}
                </div>
            `;
            
            if (testResults.errors.length > 0) {
                html += '<div class="section error"><h4>ğŸ”´ å‘ç°çš„é”™è¯¯:</h4><pre>';
                testResults.errors.forEach((error, index) => {
                    html += `${index + 1}. [${error.timestamp}] ${error.type}:\\n`;
                    html += `   ${error.message}\\n`;
                    if (error.url) html += `   URL: ${error.url}\\n`;
                    if (error.status) html += `   Status: ${error.status}\\n`;
                    html += '\\n';
                });
                html += '</pre></div>';
            }
            
            if (testResults.networkErrors.length > 0) {
                html += '<div class="section error"><h4>ğŸŒ ç½‘ç»œé”™è¯¯:</h4><pre>';
                testResults.networkErrors.forEach((error, index) => {
                    html += `${index + 1}. [${error.timestamp}] ${error.url}\\n`;
                    html += `   ${error.error || error.status + ' ' + error.statusText}\\n\\n`;
                });
                html += '</pre></div>';
            }
            
            if (testResults.errors.length === 0 && testResults.networkErrors.length === 0) {
                html += '<div class="section success"><h4>âœ… æ²¡æœ‰å‘ç°ä¸¥é‡é”™è¯¯</h4>åº”ç”¨ä¼¼ä¹è¿è¡Œæ­£å¸¸ã€‚</div>';
            }
            
            document.getElementById('results').innerHTML = html;
            updateStatus(`æ£€æŸ¥å®Œæˆ - å‘ç° ${testResults.errors.length} ä¸ªé”™è¯¯`, 
                        testResults.errors.length > 0 ? 'error' : 'success');
        }

        function exportReport() {
            const report = {
                timestamp: new Date().toISOString(),
                testDuration: testResults.endTime ? (testResults.endTime - testResults.startTime) : null,
                summary: {
                    totalErrors: testResults.errors.length,
                    totalWarnings: testResults.warnings.length,
                    totalNetworkErrors: testResults.networkErrors.length
                },
                details: testResults,
                recommendations: generateRecommendations()
            };
            
            const blob = new Blob([JSON.stringify(report, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `taskwall-error-report-${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.json`;
            a.click();
            
            updateStatus('æŠ¥å‘Šå·²å¯¼å‡º', 'success');
        }

        function generateRecommendations() {
            const recommendations = [];
            
            if (testResults.networkErrors.some(e => e.url.includes(':8000'))) {
                recommendations.push('åç«¯æœåŠ¡å¯èƒ½æœªå¯åŠ¨æˆ–æ— æ³•è®¿é—®ï¼Œè¯·æ£€æŸ¥ http://localhost:8000');
            }
            
            if (testResults.errors.some(e => e.type === 'js_load_error')) {
                recommendations.push('JavaScriptæ–‡ä»¶åŠ è½½å¤±è´¥ï¼Œå¯èƒ½æ˜¯Viteå¼€å‘æœåŠ¡å™¨é—®é¢˜');
            }
            
            if (testResults.errors.length === 0 && testResults.networkErrors.length === 0) {
                recommendations.push('åº”ç”¨è¿è¡Œæ­£å¸¸ï¼Œæ²¡æœ‰å‘ç°ä¸¥é‡é—®é¢˜');
            }
            
            return recommendations;
        }

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            updateStatus('é”™è¯¯æ£€æŸ¥å·¥å…·å·²å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»"å¼€å§‹æµ‹è¯•"å¼€å§‹æ£€æŸ¥', 'success');
        });
    </script>
</body>
</html>