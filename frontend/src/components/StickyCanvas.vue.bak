Â·Â·<template>
  <div 
    ref="canvasContainer" 
    :class="['sticky-canvas', { 'dragging': unifiedDrag.isTaskDragging(), 'panning': panZoom.panState.value.isPanning }]"
    @wheel.passive="handleCanvasWheel"
    @contextmenu.prevent
  >
    <!-- Canvas content with transform -->
    <div 
      ref="canvasContentRef"
      class="canvas-content" 
      :style="panZoom.canvasContentStyle.value"
    >
      <!-- Canvas background grid -->
      <CanvasGrid />
      
      <!-- è™šæ‹ŸåŒ–ä»»åŠ¡æ¸²æŸ“ - æ”¯æŒæ‡’åŠ è½½å’ŒLOD -->
      <div
        v-for="virtualTask in virtualizedTasks.visibleTasks.value"
        :key="`task-${virtualTask.id}`"
        :class="['task-wrapper', { 'dragging': unifiedDrag.getCurrentDragTask()?.id === virtualTask.id }]"
        :style="getTaskPosition(virtualTask)"
        :data-task-id="virtualTask.id"
      >
        <!-- ä½¿ç”¨LODä»»åŠ¡å¡ç‰‡ -->
        <TaskCardLOD
          :task="virtualTask"
          :lod-level="virtualTask.lodLevel"
          :distance="virtualTask.distance"
          :is-selected="selectedTask?.id === virtualTask.id"
          @select="selectTask"
          @openDetails="handleOpenDetails"
          @startConnection="connections.startConnection"
          @getTaskPosition="getTaskPositionData"
          @subtasksCreated="handleSubtasksCreated"
        />
      </div>

      <!-- æ‡’åŠ è½½ä»»åŠ¡è¿çº¿ -->
      <TaskConnectionsLazy
        :connections="dependencies"
        :task-positions="positions.taskPositions.value"
        :task-dimensions="positions.taskDimensions.value"
        :canvas-width="canvasSize.width"
        :canvas-height="canvasSize.height"
        :viewport="panZoom.viewport.value"
        :preview-connection="connections.connectionPreview.value"
        :max-render-connections="200"
        :viewport-margin="1200"
        :lod-distances="[1500, 3000, 6000]"
        @connection-double-click="handleConnectionDoubleClick"
      />

      <!-- Island View -->
      <IslandView
        ref="islandViewRef"
        :enabled="islandView"
        :islands="islands"
        :container-width="containerWidth"
        :container-height="containerHeight"
        :task-positions="positions.taskPositions.value"
        @toggle-island="handleToggleIsland"
        @arrange-tasks-in-islands="handleArrangeTasksInIslands"
      />
    </div>

    <!-- Mini Map -->
    <MiniMap
      :tasks="tasks"
      :task-positions="positions.taskPositions.value"
      :canvas-width="canvasSize.width"
      :canvas-height="canvasSize.height"
      :viewport-x="-panZoom.viewport.value.x / panZoom.viewport.value.scale"
      :viewport-y="-panZoom.viewport.value.y / panZoom.viewport.value.scale"
      :viewport-width="panZoom.viewportWidth.value"
      :viewport-height="panZoom.viewportHeight.value"
      :selected-task-id="selectedTask?.id"
      @focus-task="focusOnTask"
      @move-viewport="handleViewportMove"
    />

  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, nextTick, computed, watch, toRef } from 'vue'
import TaskCard from './TaskCard.vue'
import TaskCardLOD from './task/TaskCardLOD.vue'
import TaskConnections from './TaskConnections.vue'
import TaskConnectionsLazy from './task/TaskConnectionsLazy.vue'
import MiniMap from './MiniMap.vue'
import IslandView from './IslandView.vue'
import CanvasGrid from './canvas/CanvasGrid.vue'
import { type Task, useTaskStore } from '@/stores/tasks'
import { useSettingsStore } from '@/stores/settings'
import { autoArrange } from '@/utils/autoArrange'
import { ElMessage, ElMessageBox } from 'element-plus'
import { throttle } from 'lodash'

// Import composables
import { useUnifiedDragSystem } from '@/composables/useUnifiedDragSystem'
import { useUltraPerformancePanZoom } from '@/composables/useUltraPerformancePanZoom'
import { useTaskPositions } from '@/composables/useTaskPositions'
import { useConnections } from '@/composables/useConnections'
import { useVirtualizedTasks } from '@/composables/useVirtualizedTasks'

interface Props {
  tasks: Task[]
  selectedTask?: Task | null
  islandView?: boolean
  islandViewEnabled?: boolean
  themeIslands?: any[]
}

const props = defineProps<Props>()
const emit = defineEmits<{
  selectTask: [task: Task | null]
  openTaskDetails: [task: Task, position: { x: number, y: number }]
  autoArrangeComplete: []
}>()

const settingsStore = useSettingsStore()
const taskStore = useTaskStore()

const canvasContainer = ref<HTMLElement>()
const taskElements = ref<HTMLElement[]>([])
const islandViewRef = ref<InstanceType<typeof IslandView>>()

// çŠ¶æ€ï¼šç”¨äºåŒºåˆ†ç”»å¸ƒä¸Šçš„å•å‡»å’Œæ‹–åŠ¨
const canvasClickState = ref<{
  isDown: boolean
  startX: number
  startY: number
  isDragging: boolean
}>({ isDown: false, startX: 0, startY: 0, isDragging: false })

// Canvas size
const canvasSize = ref({ width: 6000, height: 6000 })

// Container dimensions for island view
const containerWidth = computed(() => canvasContainer.value?.getBoundingClientRect().width || 1200)
const containerHeight = computed(() => canvasContainer.value?.getBoundingClientRect().height || 800)

// Use composables
const tasksRef = toRef(props, 'tasks')

// Task positions management
const positions = useTaskPositions(tasksRef, {
  onPositionChange: async (taskId: number, x: number, y: number) => {
    try {
      await taskStore.updateTask(taskId, { 
        position_x: x, 
        position_y: y 
      })
    } catch (error) {
      console.error('ä¿å­˜ä»»åŠ¡ä½ç½®å¤±è´¥:', error)
    }
  },
  onBoundsUpdate: (bounds) => {
    canvasSize.value = bounds
  }
})

// Pan and zoom management
const panZoom = useUltraPerformancePanZoom(
  canvasContainer,
  canvasSize,
  {
    onViewportChange: (viewport: any) => {
      // è§¦å‘è™šæ‹ŸåŒ–æ›´æ–°
      virtualizedTasks.forceUpdate()
    }
  }
)

// è™šæ‹ŸåŒ–ä»»åŠ¡ç³»ç»Ÿ - æ‡’åŠ è½½å’ŒLOD
const virtualizedTasks = useVirtualizedTasks(
  tasksRef,
  positions.taskPositions,
  panZoom.viewport,
  canvasContainer,
  {
    viewportMargin: 800,      // 800pxé¢„åŠ è½½è¾¹è·
    maxRenderTasks: 150,      // æœ€å¤šæ¸²æŸ“150ä¸ªä»»åŠ¡
    lodDistances: [1000, 2500, 5000], // LODè·ç¦»é˜ˆå€¼
    enablePredictiveLoading: true
  }
)

// ç»Ÿä¸€æ‹–åŠ¨ç³»ç»Ÿ
const unifiedDrag = useUnifiedDragSystem(
  canvasContainer,
  panZoom.viewport,
  positions.taskPositions,
  {
    onCanvasPanStart: () => {
      console.log('ğŸš€ [StickyCanvas] ç”»å¸ƒå¹³ç§»å¼€å§‹')
    },
    onCanvasPanMove: (deltaX: number, deltaY: number) => {
      // ä½¿ç”¨panZoomçš„é«˜æ€§èƒ½å¹³ç§»æ–¹æ³•
      panZoom.panBy(deltaX, deltaY)
    },
    onCanvasPanEnd: () => {
      console.log('ğŸ›‘ [StickyCanvas] ç”»å¸ƒå¹³ç§»ç»“æŸ')
    },
    onTaskDragStart: (task: Task) => {
      console.log('ğŸš€ [StickyCanvas] ä»»åŠ¡æ‹–åŠ¨å¼€å§‹:', task.title)
      selectTask(task)
    },
    onTaskDragMove: (task: Task, position: { x: number; y: number }) => {
      // é«˜æ€§èƒ½å®æ—¶ä½ç½®æ›´æ–° - ç§»é™¤console.logæå‡æ€§èƒ½
      positions.setTaskPosition(task.id, position.x, position.y, true)
    },
    onTaskDragEnd: (task: Task, position: { x: number; y: number }) => {
      console.log('ğŸ›‘ [StickyCanvas] ä»»åŠ¡æ‹–åŠ¨ç»“æŸ:', task.title, position)
      // è·å–çº¦æŸåçš„ä½ç½®å¹¶ä¿å­˜åˆ°åç«¯
      const constrainedPosition = positions.taskPositions.value[task.id] || position
      updateTaskPosition(task.id, constrainedPosition.x, constrainedPosition.y)
    },
    onTaskSelect: (task: Task | null) => {
      emit('selectTask', task)
    }
  }
)

// Connection management
const connections = useConnections(canvasContainer, panZoom.viewport, {
  onConnectionCreate: async (fromTaskId, toTaskId) => {
    try {
      await taskStore.createDependency({
        from_task_id: fromTaskId,
        to_task_id: toTaskId,
        dependency_type: 'blocks'
      })
      console.log('è¿æ¥åˆ›å»ºæˆåŠŸ:', fromTaskId, '->', toTaskId)
      await taskStore.fetchDependencies()
    } catch (error) {
      console.error('Failed to create dependency:', error)
      ElMessage.error('åˆ›å»ºè¿æ¥å¤±è´¥')
    }
  },
  onConnectionEnd: () => {
    // é‡ç½®æ‰€æœ‰ä»»åŠ¡å¡ç‰‡çš„è¿æ¥çŠ¶æ€
    console.log('è¿æ¥ç»“æŸï¼Œé‡ç½®æ‰€æœ‰ä»»åŠ¡çš„è¿æ¥çŠ¶æ€')
    // è¿™é‡Œå¯ä»¥é€šè¿‡äº‹ä»¶æˆ–å…¶ä»–æ–¹å¼é€šçŸ¥ä»»åŠ¡å¡ç‰‡é‡ç½®çŠ¶æ€
    // ç”±äºæˆ‘ä»¬æ²¡æœ‰ç›´æ¥çš„å¼•ç”¨ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å…¨å±€äº‹ä»¶
    document.dispatchEvent(new CustomEvent('connection-ended'))
  }
})

// æ·»åŠ ä¸€ä¸ªcanvas contentå…ƒç´ çš„å¼•ç”¨
const canvasContentRef = ref<HTMLElement>()

// Dependencies from store
const dependencies = computed(() => taskStore.dependencies)


// ä½¿ç”¨è™šæ‹ŸåŒ–ç³»ç»Ÿæ›¿ä»£æ—§çš„å¯è§ä»»åŠ¡è®¡ç®—
// æ—§çš„ visibleTasks computed å·²è¢« virtualizedTasks.visibleTasks æ›¿ä»£

// æ€§èƒ½ç›‘æ§
const performanceMetrics = ref({
  lastRenderTime: 0,
  frameCount: 0,
  avgFrameTime: 0
})

// ä¼˜åŒ–çš„æ¸²æŸ“å‡½æ•°
function optimizedRender() {
  const startTime = performance.now()
  
  // ä½¿ç”¨ nextTick ç¡®ä¿ DOM æ›´æ–°å®Œæˆ
  nextTick(() => {
    const endTime = performance.now()
    const renderTime = endTime - startTime
    
    performanceMetrics.value.lastRenderTime = renderTime
    performanceMetrics.value.frameCount++
    
    // è®¡ç®—å¹³å‡å¸§æ—¶é—´
    performanceMetrics.value.avgFrameTime = 
      (performanceMetrics.value.avgFrameTime * (performanceMetrics.value.frameCount - 1) + renderTime) / 
      performanceMetrics.value.frameCount
    
    // æ€§èƒ½è­¦å‘Š
    if (renderTime > 16.67) { // è¶…è¿‡60fps
      console.warn(`Canvas render time: ${renderTime.toFixed(2)}ms (over 16.67ms threshold)`)
    }
  })
}

// ä½¿ç”¨ throttle é™åˆ¶é«˜é¢‘æ“ä½œ - é’ˆå¯¹å¹³ç§»ä¼˜åŒ–
const throttledViewportUpdate = throttle(() => {
  // åªæœ‰åœ¨éå¹³ç§»çŠ¶æ€æˆ–å¹³ç§»ç»“æŸæ—¶æ‰è§¦å‘é‡æ–°è®¡ç®—
  if (!panZoom.panState.value.isPanning) {
    optimizedRender()
  }
}, 16) // 60fps

// ä¸“é—¨ä¸ºå¹³ç§»ä¼˜åŒ–çš„æ›´è½»é‡çº§æ›´æ–°å‡½æ•°
const lightweightPanUpdate = throttle(() => {
  // å¹³ç§»æ—¶ä¸è§¦å‘å¤æ‚çš„é‡æ–°æ¸²æŸ“ï¼Œåªæ›´æ–°å˜æ¢
  // è¿™æ ·å¯ä»¥ä¿æŒæµç•…çš„å¹³ç§»æ•ˆæœ
}, 8) // 120fpsï¼Œæ›´æµç•…çš„å¹³ç§»

// åœ¨script setupé¡¶éƒ¨æ·»åŠ ä»»åŠ¡å°ºå¯¸ç®¡ç†
const taskDimensions = ref<{ [key: number]: { width: number; height: number } }>({})

// Methods
function getTaskPosition(task: Task) {
  const position = positions.taskPositions.value[task.id] || positions.getDefaultPosition(task)
  const isDragging = unifiedDrag.getCurrentDragTask()?.id === task.id
  
  // æ‹–åŠ¨æ—¶ä½¿ç”¨ç‰¹æ®Šæ ·å¼ä¼˜åŒ–
  if (isDragging) {
    return {
      position: 'absolute' as const,
      left: '0px',
      top: '0px',
      transform: `translate3d(${position.x}px, ${position.y}px, 0) scale(1.02)`,
      zIndex: 1000,
      willChange: 'transform' as const,
      transition: 'none' as const, // æ‹–åŠ¨æ—¶ç¦ç”¨è¿‡æ¸¡åŠ¨ç”»
      pointerEvents: 'auto' as const
    }
  }
  
  return {
    position: 'absolute' as const,
    left: '0px',
    top: '0px',
    transform: `translate3d(${position.x}px, ${position.y}px, 0)`,
    zIndex: 1,
    willChange: 'auto' as const,
    transition: 'transform 0.15s ease-out' as const, // éæ‹–åŠ¨æ—¶çš„å¹³æ»‘è¿‡æ¸¡
    pointerEvents: 'auto' as const
  }
}

// handleTaskMouseDown å·²è¢«ç»Ÿä¸€æ‹–åŠ¨ç³»ç»Ÿæ›¿ä»£ï¼Œä¸å†éœ€è¦

function selectTask(task: Task) {
  emit('selectTask', task)
}

function handleOpenDetails(task: Task, position: { x: number, y: number }) {
  emit('openTaskDetails', task, position)
}

// è·å–ä»»åŠ¡ä½ç½®æ•°æ®
function getTaskPositionData(taskId: number) {
  return positions.taskPositions.value[taskId] || { x: 0, y: 0 }
}

// å¤„ç†å­ä»»åŠ¡åˆ›å»ºå®Œæˆ
function handleSubtasksCreated(data: { parentTask: Task, subtasks: Task[] }) {
  console.log('å­ä»»åŠ¡åˆ›å»ºå®Œæˆ:', data)
  
  // åˆ·æ–°ä»»åŠ¡ä½ç½®æ•°æ®
  positions.updateTaskDimensions()
  
  // å¯ä»¥æ·»åŠ å…¶ä»–å¤„ç†é€»è¾‘ï¼Œæ¯”å¦‚è‡ªåŠ¨èšç„¦åˆ°æ–°åˆ›å»ºçš„å­ä»»åŠ¡åŒºåŸŸ
  if (data.subtasks.length > 0) {
    const firstSubtask = data.subtasks[0]
    const position = positions.taskPositions.value[firstSubtask.id]
    if (position) {
      // å¯ä»¥æ·»åŠ å¹³æ»‘æ»šåŠ¨åˆ°å­ä»»åŠ¡ä½ç½®çš„é€»è¾‘
      console.log('æ–°å­ä»»åŠ¡ä½ç½®:', position)
    }
  }
}

// å¤„ç†åŒå‡»è¿çº¿åˆ é™¤
async function handleConnectionDoubleClick(connection: any) {
  try {
    // è·å–ä»»åŠ¡ä¿¡æ¯ç”¨äºç¡®è®¤å¯¹è¯æ¡†
    const fromTask = props.tasks.find(t => t.id === connection.from_task_id)
    const toTask = props.tasks.find(t => t.id === connection.to_task_id)
    
    if (!fromTask || !toTask) {
      ElMessage.error('æ— æ³•æ‰¾åˆ°ç›¸å…³ä»»åŠ¡')
      return
    }

    // æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
    await ElMessageBox.confirm(
      `ç¡®å®šè¦åˆ é™¤ä»ã€Œ${fromTask.title}ã€åˆ°ã€Œ${toTask.title}ã€çš„è¿æ¥å—ï¼Ÿ`,
      'åˆ é™¤è¿æ¥',
      {
        confirmButtonText: 'åˆ é™¤',
        cancelButtonText: 'å–æ¶ˆ',
        type: 'warning',
        confirmButtonClass: 'el-button--danger'
      }
    )

    // ç”¨æˆ·ç¡®è®¤åï¼Œè°ƒç”¨åˆ é™¤API
    await taskStore.deleteDependency(connection.from_task_id, connection.to_task_id)
    
    ElMessage.success('è¿æ¥å·²åˆ é™¤')
    
  } catch (error: any) {
    if (error !== 'cancel') { // ç”¨æˆ·å–æ¶ˆæ“ä½œä¸æ˜¾ç¤ºé”™è¯¯
      console.error('åˆ é™¤è¿æ¥å¤±è´¥:', error)
      ElMessage.error('åˆ é™¤è¿æ¥å¤±è´¥')
    }
  }
}

// ResizeObserverè®¾ç½®
function setupDimensionObserver() {
  return positions.setupDimensionObserver()
}

// handleCanvasMouseDown å·²è¢«ç»Ÿä¸€æ‹–åŠ¨ç³»ç»Ÿæ›¿ä»£
/*
function handleCanvasMouseDown(event: MouseEvent) {
  // --- 1. ä¸­é”®æ‹–åŠ¨ (æœ€é«˜ä¼˜å…ˆçº§) ---
  if (event.button === 1) {
    console.log('ğŸš€ [Refactor] ä¸­é”®æŒ‰ä¸‹ï¼Œç«‹å³å¼€å§‹ç”»å¸ƒå¹³ç§»ã€‚')
    event.preventDefault()
    event.stopPropagation()
    panZoom.startPan(event)
    return // ç¡®ä¿ä¸æ‰§è¡Œä»»ä½•å…¶ä»–é€»è¾‘
  }

  const target = event.target as HTMLElement
  const isTaskClick = target.closest('.task-wrapper')

  // --- 2. å·¦é”®ç‚¹å‡»ä»»åŠ¡ (ç”±ä»»åŠ¡è‡ªèº«å¤„ç†) ---
  if (event.button === 0 && isTaskClick) {
    console.log('ğŸ–±ï¸ [Refactor] å·¦é”®ç‚¹å‡»ä»»åŠ¡ï¼Œç”± TaskCard å¤„ç†ã€‚')
    return // ä¸å¤„ç†ï¼Œè®© handleTaskMouseDown ç”Ÿæ•ˆ
  }

  // --- 3. å·¦é”®ç‚¹å‡»ç”»å¸ƒèƒŒæ™¯ (æ‹–åŠ¨æˆ–å–æ¶ˆé€‰æ‹©) ---
  if (event.button === 0 && !isTaskClick) {
    console.log('ğŸ–±ï¸ [Refactor] å·¦é”®åœ¨ç”»å¸ƒèƒŒæ™¯æŒ‰ä¸‹ï¼Œå‡†å¤‡æ‹–åŠ¨æˆ–å–æ¶ˆé€‰æ‹©ã€‚')
    event.preventDefault()
    
    // è®°å½•ç‚¹å‡»çŠ¶æ€
    canvasClickState.value = {
      isDown: true,
      startX: event.clientX,
      startY: event.clientY,
      isDragging: false
    }

    // å¼€å§‹ç”»å¸ƒå¹³ç§»ï¼ŒPanZoom composable ä¼šå¤„ç†æ‹–åŠ¨é€»è¾‘
    panZoom.startPan(event)
  }
}
*/

// ä»¥ä¸‹å‡½æ•°å·²è¢«ç»Ÿä¸€æ‹–åŠ¨ç³»ç»Ÿæ›¿ä»£
/*
function handleWindowMouseUp(event: MouseEvent) {
  if (canvasClickState.value.isDown && event.button === 0) {
    // å¦‚æœæ²¡æœ‰æ‹–åŠ¨ï¼ˆæˆ–æ‹–åŠ¨è·ç¦»å¾ˆå°ï¼‰ï¼Œåˆ™è§†ä¸ºå•å‡»
    if (!canvasClickState.value.isDragging) {
      console.log('ğŸ¯ [Refactor] æ£€æµ‹åˆ°ç”»å¸ƒå•å‡»ï¼Œå–æ¶ˆé€‰æ‹©ä»»åŠ¡ã€‚')
      emit('selectTask', null)
    } else {
      console.log('ğŸ’¨ [Refactor] ç”»å¸ƒæ‹–åŠ¨ç»“æŸã€‚')
    }
    // é‡ç½®çŠ¶æ€
    canvasClickState.value.isDown = false
    canvasClickState.value.isDragging = false
  }
}

// æ–°å¢ï¼šå¤„ç†å…¨å±€ mousemove äº‹ä»¶
function handleWindowMouseMove(event: MouseEvent) {
  if (canvasClickState.value.isDown && !canvasClickState.value.isDragging) {
    const dx = event.clientX - canvasClickState.value.startX
    const dy = event.clientY - canvasClickState.value.startY
    // å¦‚æœç§»åŠ¨è¶…è¿‡5åƒç´ ï¼Œåˆ™æ ‡è®°ä¸ºæ‹–åŠ¨çŠ¶æ€
    if (Math.sqrt(dx * dx + dy * dy) > 5) {
      console.log('ğŸ’¨ [Refactor] å¼€å§‹æ‹–åŠ¨ç”»å¸ƒã€‚')
      canvasClickState.value.isDragging = true
    }
  }
}
*/

// ResizeObserver instance
let dimensionObserver: ResizeObserver | null = null

onMounted(() => {
  // åŸæœ‰çš„mousedownç›‘å¬å™¨å·²ç»è¢«ç»Ÿä¸€æ‹–åŠ¨ç³»ç»Ÿæ›¿ä»£
  console.log('âœ… [Refactor] ç»Ÿä¸€æ‹–åŠ¨ç³»ç»Ÿå·²æ¥ç®¡äº‹ä»¶å¤„ç†ã€‚')
  
  // å…¨å±€ç›‘å¬å™¨å·²ç”±ç»Ÿä¸€æ‹–åŠ¨ç³»ç»Ÿå¤„ç†
  // window.addEventListener('mouseup', handleWindowMouseUp)
  // window.addEventListener('mousemove', handleWindowMouseMove)

  // Initialize positions for any existing tasks
  nextTick(() => {
    positions.initializeTaskPositions()
    
    // Setup dimension monitoring
    dimensionObserver = setupDimensionObserver() || null
  })

  // è¶…çº§é¢„çƒ­ç³»ç»Ÿ
  nextTick(() => {
    console.log('ğŸš€ å¼€å§‹é¢„çƒ­é«˜æ€§èƒ½ç³»ç»Ÿ...')
    
    // åˆå§‹åŒ–ç»Ÿä¸€æ‹–åŠ¨ç³»ç»Ÿ
    unifiedDrag.init(toRef(props, 'tasks'))
    
    // é¢„çƒ­ç”»å¸ƒå¹³ç§»ç¼©æ”¾ç³»ç»Ÿ
    panZoom.warmup()
    
    // é¢„çƒ­è™šæ‹ŸåŒ–ç³»ç»Ÿ
    virtualizedTasks.warmup()
    
    // é¢„çƒ­GPUå±‚
    setTimeout(() => {
      const canvasContent = canvasContainer.value?.querySelector('.canvas-content') as HTMLElement
      if (canvasContent) {
        // å¼ºåˆ¶åˆ›å»ºGPUåˆæˆå±‚
        canvasContent.style.willChange = 'transform'
        canvasContent.style.transform = 'translate3d(0,0,0)'
        
        // é¢„çƒ­ä»»åŠ¡å¡ç‰‡çš„GPUå±‚
        props.tasks.forEach(task => {
          const taskElement = document.querySelector(`[data-task-id="${task.id}"]`) as HTMLElement
          if (taskElement) {
            taskElement.style.willChange = 'transform'
            taskElement.style.transform = 'translate3d(0,0,0)'
            
            // å»¶è¿Ÿæ¢å¤æ­£å¸¸çŠ¶æ€
            setTimeout(() => {
              if (!unifiedDrag.isTaskDragging()) {
                taskElement.style.willChange = 'auto'
              }
            }, 100)
          }
        })
        
        console.log('ğŸ‰ é«˜æ€§èƒ½æ‹–åŠ¨ç³»ç»Ÿé¢„çƒ­å®Œæˆï¼')
        console.log(`ğŸ“Š è™šæ‹ŸåŒ–çŠ¶æ€: æ€»ä»»åŠ¡ ${props.tasks.length}, å¯è§ä»»åŠ¡ ${virtualizedTasks.visibleTasks.value.length}`)
      }
    }, 100)
  })
})

// Cleanup on unmount
onUnmounted(() => {
  if (dimensionObserver) {
    dimensionObserver.disconnect()
  }
  
  // ç»Ÿä¸€æ‹–åŠ¨ç³»ç»Ÿå°†åœ¨destroyä¸­æ¸…ç†è‡ªå·±çš„ç›‘å¬å™¨
  console.log('ğŸ”§ [Refactor] äº‹ä»¶æ¸…ç†äº¤ç”±ç»Ÿä¸€æ‹–åŠ¨ç³»ç»Ÿå¤„ç†ã€‚')
  
  // å…¨å±€ç›‘å¬å™¨æ¸…ç†å·²ç”±ç»Ÿä¸€æ‹–åŠ¨ç³»ç»Ÿå¤„ç†
  // window.removeEventListener('mouseup', handleWindowMouseUp)
  // window.removeEventListener('mousemove', handleWindowMouseMove)

  // Cleanupç»Ÿä¸€æ‹–åŠ¨ç³»ç»Ÿ
  unifiedDrag.destroy()
  connections.cleanup()
  panZoom.cleanup()
})

// Re-initialize positions when tasks change
function updateTaskPositions() {
  nextTick(() => {
    positions.initializeTaskPositions()
  })
}

// Auto arrange functionality
function getTaskSizes(): Map<number, { width: number; height: number }> {
  const sizes = new Map()
  
  props.tasks.forEach(task => {
    const element = document.querySelector(`[data-task-id="${task.id}"]`) as HTMLElement
    if (element) {
      sizes.set(task.id, {
        width: element.offsetWidth || 200,
        height: element.offsetHeight || 120
      })
    } else {
      sizes.set(task.id, { width: 200, height: 120 })
    }
  })
  
  return sizes
}

function triggerAutoArrange() {
  if (!canvasContainer.value || props.tasks.length === 0) return
  
  const containerRect = canvasContainer.value.getBoundingClientRect()
  const taskSizes = getTaskSizes()
  
  const newPositions = autoArrange(
    props.tasks,
    containerRect.width,
    containerRect.height,
    settingsStore.autoArrangeOptions,
    taskSizes
  )
  
  if (settingsStore.autoArrangeOptions.animated) {
    // åŠ¨ç”»è¿‡æ¸¡åˆ°æ–°ä½ç½®
    animateToPositions(newPositions)
  } else {
    // ç›´æ¥è®¾ç½®æ–°ä½ç½®
    positions.setTaskPositions(newPositions)
  }
  
  emit('autoArrangeComplete')
}

function animateToPositions(newPositions: { [key: number]: { x: number; y: number } }) {
  const duration = 500 // åŠ¨ç”»æŒç»­æ—¶é—´
  const startTime = performance.now()
  const startPositions = { ...positions.taskPositions.value }
  
  function animate(currentTime: number) {
    const elapsed = currentTime - startTime
    const progress = Math.min(elapsed / duration, 1)
    
    // ä½¿ç”¨easeInOutCubicç¼“åŠ¨å‡½æ•°
    const easeProgress = progress < 0.5
      ? 4 * progress * progress * progress
      : 1 - Math.pow(-2 * progress + 2, 3) / 2
    
    // æ’å€¼è®¡ç®—å½“å‰ä½ç½®
    const currentPositions: { [key: number]: { x: number; y: number } } = {}
    Object.keys(newPositions).forEach(taskIdStr => {
      const taskId = parseInt(taskIdStr)
      const startPos = startPositions[taskId] || { x: 0, y: 0 }
      const endPos = newPositions[taskId]
      
      currentPositions[taskId] = {
        x: startPos.x + (endPos.x - startPos.x) * easeProgress,
        y: startPos.y + (endPos.y - startPos.y) * easeProgress
      }
    })
    
    positions.setTaskPositions(currentPositions)
    
    if (progress < 1) {
      requestAnimationFrame(animate)
    }
  }
  
  requestAnimationFrame(animate)
}

// Island layout functionality
const islandView = ref(false)
const islands = ref<any[]>([])

// Sync island view with props
watch(() => props.islandViewEnabled, (enabled) => {
  if (enabled !== undefined) {
    islandView.value = enabled
  }
}, { immediate: true })

watch(() => props.themeIslands, (newIslands) => {
  if (newIslands) {
    islands.value = newIslands
    if (newIslands.length > 0 && props.islandViewEnabled) {
      arrangeTasksInIslands()
    }
  }
}, { immediate: true })

function applyIslandLayout(islandData: any[]) {
  console.log('Applying island layout:', islandData)
  islandView.value = true
  islands.value = islandData
  
  // Calculate island positions and layout
  arrangeTasksInIslands()
}

function arrangeTasksInIslands() {
  if (!canvasContainer.value || islands.value.length === 0) return
  
  // ä½¿ç”¨requestAnimationFrameæ¥ä¼˜åŒ–æ€§èƒ½
  requestAnimationFrame(() => {
    const containerRect = canvasContainer.value!.getBoundingClientRect()
    const containerWidth = containerRect.width
    const containerHeight = containerRect.height
    
    // Calculate grid layout for islands
    const islandsCount = islands.value.length
    const cols = Math.ceil(Math.sqrt(islandsCount))
    const rows = Math.ceil(islandsCount / cols)
    
    const islandWidth = containerWidth / cols
    const islandHeight = containerHeight / rows
    const padding = 20
    
    // æ‰¹é‡è®¡ç®—æ‰€æœ‰ä½ç½®ï¼Œé¿å…é¢‘ç¹çš„DOMæ“ä½œ
    const newPositions: { [key: number]: { x: number; y: number } } = {}
    
    islands.value.forEach((island, index) => {
      const row = Math.floor(index / cols)
      const col = index % cols
      
      const islandX = col * islandWidth + padding
      const islandY = row * islandHeight + padding
      const availableWidth = islandWidth - 2 * padding
      const availableHeight = islandHeight - 2 * padding
      
      // Arrange tasks within this island
      arrangeTasksInIsland(island.tasks, islandX, islandY, availableWidth, availableHeight, newPositions)
    })
    
    // æ‰¹é‡æ›´æ–°ä½ç½®
    Object.assign(positions.taskPositions.value, newPositions)
  })
}

function arrangeTasksInIsland(
  tasks: any[], 
  startX: number, 
  startY: number, 
  width: number, 
  height: number, 
  newPositions?: { [key: number]: { x: number; y: number } }
) {
  if (!tasks || tasks.length === 0) return
  
  const taskWidth = 200
  const taskHeight = 120
  const spacing = 10
  
  const cols = Math.floor(width / (taskWidth + spacing))
  
  tasks.forEach((task, index) => {
    const row = Math.floor(index / cols)
    const col = index % cols
    
    const x = startX + col * (taskWidth + spacing)
    const y = startY + row * (taskHeight + spacing) + 30 // Reserve space for island header
    
    if (newPositions) {
      newPositions[task.id] = { x, y }
    } else {
      positions.taskPositions.value[task.id] = { x, y }
    }
  })
}

function focusOnTask(taskId: number) {
  // Find the task and center the view on it
  const task = props.tasks.find(t => t.id === taskId)
  if (task && positions.taskPositions.value[taskId]) {
    const position = positions.taskPositions.value[taskId]
    
    // è®¡ç®—å®¹å™¨ä¸­å¿ƒç‚¹
    if (canvasContainer.value) {
      const containerRect = canvasContainer.value.getBoundingClientRect()
      const centerX = containerRect.width / 2
      const centerY = containerRect.height / 2
      
      // å°†ä»»åŠ¡å®šä½åˆ°ç”»å¸ƒä¸­å¿ƒ
      panZoom.viewport.value.x = centerX - (position.x * panZoom.viewport.value.scale) - 100 // 100æ˜¯ä»»åŠ¡å¡ç‰‡å®½åº¦çš„ä¸€åŠ
      panZoom.viewport.value.y = centerY - (position.y * panZoom.viewport.value.scale) - 60  // 60æ˜¯ä»»åŠ¡å¡ç‰‡é«˜åº¦çš„ä¸€åŠ
    }
    
    // æ·»åŠ é«˜äº®æ•ˆæœ
    const element = document.querySelector(`[data-task-id="${taskId}"]`) as HTMLElement
    if (element) {
      // æ·»åŠ ä¸´æ—¶é«˜äº®æ•ˆæœ
      element.style.boxShadow = '0 0 20px #2563eb, 0 0 40px rgba(37, 99, 235, 0.5)'
      element.style.transform = 'translateY(-4px) scale(1.05)'
      element.style.transition = 'all 0.3s ease'
      
      setTimeout(() => {
        element.style.boxShadow = ''
        element.style.transform = ''
        element.style.transition = ''
      }, 2000)
    }
  }
}

// æ·»åŠ æ–°å‡½æ•°ï¼šå®šä½åˆ°æœ€æ–°ä»»åŠ¡
function focusOnLatestTask() {
  if (props.tasks.length === 0) return
  
  // æ‰¾åˆ°æœ€æ–°åˆ›å»ºçš„ä»»åŠ¡ï¼ˆæŒ‰åˆ›å»ºæ—¶é—´æ’åºï¼‰
  const latestTask = props.tasks.reduce((latest, current) => {
    const latestTime = new Date(latest.created_at).getTime()
    const currentTime = new Date(current.created_at).getTime()
    return currentTime > latestTime ? current : latest
  })
  
  focusOnTask(latestTask.id)
}

function exitIslandView() {
  islandView.value = false
  islands.value = []
  // Return to normal layout
  positions.initializeTaskPositions()
}

function getIslandHeaderStyle(island: any, index: number) {
  if (!canvasContainer.value) return {}
  
  const containerRect = canvasContainer.value.getBoundingClientRect()
  const containerWidth = containerRect.width
  const containerHeight = containerRect.height
  
  const islandsCount = islands.value.length
  const cols = Math.ceil(Math.sqrt(islandsCount))
  const rows = Math.ceil(islandsCount / cols)
  
  const islandWidth = containerWidth / cols
  const islandHeight = containerHeight / rows
  const padding = 20
  
  const row = Math.floor(index / cols)
  const col = index % cols
  
  const islandX = col * islandWidth + padding
  const islandY = row * islandHeight + padding
  
  return {
    position: 'absolute' as const,
    left: `${islandX}px`,
    top: `${islandY}px`,
    width: `${islandWidth - 2 * padding}px`,
    backgroundColor: island.color,
    borderColor: island.color
  }
}

function handleToggleIsland(island: any) {
  island.collapsed = !island.collapsed
  
  // Hide/show tasks in this island
  island.tasks.forEach((task: any) => {
    const element = document.querySelector(`[data-task-id="${task.id}"]`) as HTMLElement
    if (element) {
      if (island.collapsed) {
        element.style.display = 'none'
      } else {
        element.style.display = 'block'
      }
    }
  })
}

function handleArrangeTasksInIslands() {
  arrangeTasksInIslands()
}

function handleViewportMove(x: number, y: number) {
  // Update viewport position for infinite canvas
  panZoom.viewport.value.x = -x * panZoom.viewport.value.scale
  panZoom.viewport.value.y = -y * panZoom.viewport.value.scale
}

// Connection mode functions
function enterConnectionMode(fromTaskId: number) {
  connections.enterConnectionMode(fromTaskId)
}

function handleConnectionTargetClick(event: MouseEvent) {
  // This is handled by the connections composable
}

function exitConnectionMode() {
  connections.exitConnectionMode()
}

// handleCanvasAuxClick å·²è¢«ç»Ÿä¸€æ‹–åŠ¨ç³»ç»Ÿæ›¿ä»£
/*
function handleCanvasAuxClick(event: MouseEvent) {
  console.log('ğŸ¯ è¾…åŠ©ç‚¹å‡»äº‹ä»¶:', event.button)
  
  // é˜»æ­¢ä¸­é”®çš„é»˜è®¤è¡Œä¸ºï¼ˆå¦‚æ‰“å¼€æ–°æ ‡ç­¾é¡µç­‰ï¼‰
  if (event.button === 1) {
    console.log('ğŸš« é˜»æ­¢ä¸­é”®é»˜è®¤è¡Œä¸º')
    event.preventDefault()
    event.stopPropagation()
  }
}
*/

// å¤„ç†æ»šè½®äº‹ä»¶
function handleCanvasWheel(event: WheelEvent) {
  console.log('ğŸ¯ æ»šè½®äº‹ä»¶è§¦å‘')
  event.preventDefault()
  panZoom.handleWheel(event)
}




// Keyboard shortcuts
function handleKeyDown(event: KeyboardEvent) {
  // Shift + A: Open AI smart creation dialog
  if (event.shiftKey && event.key === 'A') {
    event.preventDefault()
    openSmartCreationDialog()
  }
}

// Initialize viewport on mount
onMounted(() => {
  centerViewport()
  
  // Add keyboard event listener
  document.addEventListener('keydown', handleKeyDown)
})

onUnmounted(() => {
  // Clean up keyboard event listener
  document.removeEventListener('keydown', handleKeyDown)
})

// Expose functions
defineExpose({
  triggerAutoArrange,
  applyIslandLayout,
  focusOnTask,
  focusOnLatestTask,
  exitIslandView,
  enterConnectionMode,
  centerViewport,
  resetZoom
})

// Note: Watch for tasks is already handled above in the debug section

// å±…ä¸­è§†å£å‡½æ•°
function centerViewport() {
  if (!canvasContainer.value) return
  
  const containerRect = canvasContainer.value.getBoundingClientRect()
  panZoom.viewport.value.x = (containerRect.width - canvasSize.value.width * panZoom.viewport.value.scale) / 2
  panZoom.viewport.value.y = (containerRect.height - canvasSize.value.height * panZoom.viewport.value.scale) / 2
}

// é‡ç½®ç¼©æ”¾å‡½æ•°
function resetZoom() {
  panZoom.viewport.value.scale = 1
  centerViewport()
}

// ä»»åŠ¡ä½ç½®æ›´æ–°ä¼˜åŒ–
async function updateTaskPosition(taskId: number, x: number, y: number) {
  try {
    await taskStore.updateTask(taskId, {
      position_x: x,
      position_y: y
    })
  } catch (error) {
    console.error('Failed to update task position:', error)
    // å›æ»šä½ç½®
    const task = props.tasks.find(t => t.id === taskId)
    if (task) {
      positions.taskPositions.value[taskId] = {
        x: task.position_x || 0,
        y: task.position_y || 0
      }
    }
  }
}

// ä»»åŠ¡å°ºå¯¸æ›´æ–°å¤„ç†
function handleTaskDimensionsUpdate(taskId: number, dimensions: { width: number; height: number }) {
  taskDimensions.value[taskId] = dimensions
}
</script>

<style scoped>
/* Modern Sticky Canvas - Enhanced Design */
.sticky-canvas {
  position: relative;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
  overflow: hidden;
  cursor: grab;
  user-select: none;
  /* ç§»é™¤è¿‡æ¸¡æ•ˆæœï¼Œæå‡æ€§èƒ½ */
}

.sticky-canvas:active {
  cursor: grabbing;
}

.sticky-canvas.dragging {
  cursor: grabbing;
}

.sticky-canvas.panning {
  cursor: grabbing;
}

/* è¶…é«˜æ€§èƒ½ç”»å¸ƒå†…å®¹ */
.canvas-content {
  position: relative;
  width: 100%;
  height: 100%;
  transform-origin: 0 0;
  /* GPUåŠ é€Ÿé…ç½® */
  will-change: transform;
  contain: strict; /* ä¸¥æ ¼éš”ç¦»ï¼Œæœ€å¤§åŒ–æ€§èƒ½ */
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
  transform-style: preserve-3d;
  isolation: isolate;
  /* å¼ºåˆ¶ç¡¬ä»¶åŠ é€Ÿ */
  transform: translateZ(0);
}

/* é«˜æ€§èƒ½çŠ¶æ€ä¼˜åŒ– */
.panning .canvas-content {
  transition: none !important;
  will-change: transform;
}

.panning .task-wrapper {
  transition: none !important;
  will-change: transform;
}

.dragging .task-wrapper {
  transition: none !important;
  will-change: transform;
  z-index: 1000; /* æ‹–æ‹½æ—¶ç½®é¡¶ */
}

/* ä»»åŠ¡æ‹–æ‹½æ—¶çš„æ€§èƒ½ä¼˜åŒ– */
.task-wrapper.dragging {
  contain: strict;
  will-change: transform;
  z-index: 1000;
  /* ç¦ç”¨æ‰€æœ‰åŠ¨ç”»å’Œè¿‡æ¸¡ */
  animation: none !important;
  transition: none !important;
}

/* Modern Canvas Grid */
.canvas-grid {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0.4;
  z-index: 0;
  pointer-events: none;
  background-size: 40px 40px;
  background-image: 
    linear-gradient(rgba(102, 126, 234, 0.1) 1px, transparent 1px),
    linear-gradient(90deg, rgba(102, 126, 234, 0.1) 1px, transparent 1px);
  background-position: 0 0, 0 0;
  /* ç§»é™¤è¿‡æ¸¡æ•ˆæœ */
}

/* Enhanced grid dots for modern feel - ç®€åŒ–åŠ¨ç”» */
.canvas-grid::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: radial-gradient(circle, rgba(102, 126, 234, 0.15) 1px, transparent 1px);
  background-size: 40px 40px;
  opacity: 0.6;
  /* ç§»é™¤åŠ¨ç”»ï¼Œæå‡æ€§èƒ½ */
}

/* è¶…é«˜æ€§èƒ½ä»»åŠ¡åŒ…è£…å™¨ */
.task-wrapper {
  position: absolute;
  cursor: grab;
  user-select: none;
  z-index: 1;
  contain: strict; /* ä¸¥æ ¼éš”ç¦»ï¼Œæœ€å¤§åŒ–æ€§èƒ½ */
  transform: translate3d(0, 0, 0);
  /* ç®€åŒ–è¿›å…¥åŠ¨ç”» */
  animation: taskFadeIn 0.3s ease-out;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
  will-change: auto;
  /* GPUå±‚ä¼˜åŒ– */
  isolation: isolate;
  transform-style: preserve-3d;
}

@keyframes taskFadeIn {
  from {
    opacity: 0;
    transform: translate3d(0, 10px, 0);
  }
  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
}

.task-wrapper:active {
  cursor: grabbing;
}

/* å‡å°‘hoveræ•ˆæœçš„å¤æ‚åº¦ */
.task-wrapper:hover:not(.dragging) {
  z-index: 10;
  filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.1));
  transform: translate3d(0, -2px, 0);
  transition: all 0.2s ease-out;
}

/* Smooth transitions when not dragging */
.task-wrapper:not(.dragging) {
  transition: 
    transform 0.2s ease-out,
    filter 0.2s ease-out;
}

/* Hardware acceleration for dragging */
.task-wrapper.dragging {
  will-change: transform;
  transition: none !important;
  z-index: 1001;
  filter: drop-shadow(0 12px 24px rgba(0, 0, 0, 0.2));
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
  /* ä¸è¦è¦†ç›–transformï¼Œè®©JSåŠ¨æ€è®¾ç½®çš„ä½ç½®ç”Ÿæ•ˆ */
}

/* Enhanced Island Headers */
.island-headers {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 5;
}

.island-header {
  background: rgba(255, 255, 255, 0.95);
  border: 2px solid rgba(102, 126, 234, 0.3);
  border-radius: 16px;
  padding: 16px 20px;
  box-shadow: 
    0 8px 32px rgba(0, 0, 0, 0.1),
    0 4px 16px rgba(102, 126, 234, 0.1);
  cursor: pointer;
  pointer-events: auto;
  transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
  backdrop-filter: blur(20px);
  max-height: 120px;
  overflow: hidden;
  color: #1a202c;
  animation: islandSlideIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
  border-bottom: 4px solid rgba(102, 126, 234, 0.6);
}

@keyframes islandSlideIn {
  from {
    opacity: 0;
    transform: translateY(-30px) scale(0.9);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.island-header:hover {
  transform: translateY(-6px) scale(1.03);
  box-shadow: 
    0 16px 48px rgba(0, 0, 0, 0.15), 
    0 8px 24px rgba(102, 126, 234, 0.2);
  border-color: rgba(102, 126, 234, 0.6);
  background: rgba(255, 255, 255, 0.98);
  border-bottom-color: rgba(102, 126, 234, 0.8);
}

.island-header:active {
  transform: translateY(-3px) scale(1.01);
  transition: all 0.2s ease;
}

.island-header.collapsed {
  opacity: 0.6;
  transform: scale(0.95);
  filter: grayscale(0.3);
}

.island-title {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 700;
  font-size: 16px;
  margin-bottom: 8px;
  color: #1a202c;
}

.island-icon {
  font-size: 20px;
  animation: islandIconFloat 3s ease-in-out infinite;
}

@keyframes islandIconFloat {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-2px);
  }
}

.island-name {
  color: #1a202c;
  font-weight: 700;
  letter-spacing: -0.025em;
}

.island-count {
  color: rgba(107, 114, 128, 0.8);
  font-size: 14px;
  font-weight: 500;
  background: rgba(102, 126, 234, 0.1);
  padding: 2px 8px;
  border-radius: 8px;
  border: 1px solid rgba(102, 126, 234, 0.2);
}

.island-keywords {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  max-height: 60px;
  overflow: hidden;
}

.keyword-tag {
  background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
  color: rgba(102, 126, 234, 0.8);
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 600;
  border: 1px solid rgba(102, 126, 234, 0.2);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  animation: keywordFadeIn 0.4s ease-out;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

@keyframes keywordFadeIn {
  from {
    opacity: 0;
    transform: translateY(10px) scale(0.8);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.island-header:hover .keyword-tag {
  background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
  color: rgba(102, 126, 234, 1);
  transform: translateY(-2px) scale(1.05);
  border-color: rgba(102, 126, 234, 0.4);
  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
}

/* Enhanced Connection Mode Styles */
:deep(.connection-source) {
  box-shadow: 
    0 0 0 4px rgba(102, 126, 234, 0.3), 
    0 0 20px rgba(102, 126, 234, 0.2),
    0 8px 32px rgba(0, 0, 0, 0.1);
  border: 3px solid rgba(102, 126, 234, 0.8);
  animation: connectionPulse 2s ease-in-out infinite;
  transform: scale(1.05);
}

@keyframes connectionPulse {
  0%, 100% {
    box-shadow: 
      0 0 0 4px rgba(102, 126, 234, 0.3), 
      0 0 20px rgba(102, 126, 234, 0.2),
      0 8px 32px rgba(0, 0, 0, 0.1);
  }
  50% {
    box-shadow: 
      0 0 0 8px rgba(102, 126, 234, 0.4), 
      0 0 30px rgba(102, 126, 234, 0.3),
      0 12px 48px rgba(0, 0, 0, 0.15);
  }
}

.canvas-container.connection-mode {
  cursor: crosshair !important;
}

.canvas-container.connection-mode .canvas-grid {
  opacity: 0.6;
}

:deep(.task-card):hover.connection-target {
  border: 3px solid rgba(16, 185, 129, 0.8);
  box-shadow: 
    0 0 0 3px rgba(16, 185, 129, 0.2),
    0 8px 32px rgba(16, 185, 129, 0.1);
  transform: scale(1.03);
}

/* Enhanced Smart Task Creation FAB */
.smart-creation-fab-container {
  position: fixed;
  bottom: 32px;
  right: 32px;
  z-index: 1000;
}

.smart-creation-fab {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 18px 24px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  border-radius: 50px;
  box-shadow: 
    0 8px 32px rgba(102, 126, 234, 0.4),
    0 4px 16px rgba(102, 126, 234, 0.2);
  cursor: pointer;
  font-size: 16px;
  font-weight: 700;
  transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
  transform: translateY(0);
  backdrop-filter: blur(20px);
  min-width: 160px;
  justify-content: center;
  border: 2px solid rgba(255, 255, 255, 0.2);
}

.smart-creation-fab:hover {
  transform: translateY(-6px) scale(1.05);
  box-shadow: 
    0 16px 48px rgba(102, 126, 234, 0.6),
    0 8px 24px rgba(102, 126, 234, 0.3);
  background: linear-gradient(135deg, #5a6fd8 0%, #6b5b95 100%);
  border-color: rgba(255, 255, 255, 0.3);
}

.smart-creation-fab:active {
  transform: translateY(-3px) scale(1.02);
  transition: all 0.2s ease;
}

.fab-icon {
  font-size: 20px;
  animation: fabIconBounce 2s ease-in-out infinite;
}

@keyframes fabIconBounce {
  0%, 100% {
    transform: translateY(0) rotate(0deg);
  }
  25% {
    transform: translateY(-2px) rotate(-5deg);
  }
  75% {
    transform: translateY(-1px) rotate(5deg);
  }
}

.fab-label {
  font-weight: 700;
  letter-spacing: 0.5px;
  text-transform: uppercase;
  font-size: 14px;
}

/* Enhanced Performance Optimizations */
.sticky-canvas,
.canvas-content,
.task-wrapper {
  contain: layout style paint;
}

/* ç”»å¸ƒå¹³ç§»æ€§èƒ½ä¼˜åŒ– */
.sticky-canvas.panning {
  pointer-events: none; /* å¹³ç§»æ—¶å‡å°‘äº‹ä»¶å¤„ç† */
}

.sticky-canvas.panning .canvas-content {
  will-change: transform;
  backface-visibility: hidden;
  perspective: 1000px;
  transform-style: preserve-3d;
}

/* å¹³ç§»æ—¶æš‚åœä»»åŠ¡å¡ç‰‡çš„hoveræ•ˆæœä»¥æé«˜æ€§èƒ½ */
.sticky-canvas.panning .task-wrapper {
  pointer-events: none;
  will-change: auto; /* å¹³ç§»æ—¶ä¸éœ€è¦å•ç‹¬çš„transformä¼˜åŒ– */
}

.sticky-canvas.panning .task-wrapper:hover {
  transform: none !important; /* ç¦ç”¨hoveræ•ˆæœ */
  transition: none !important;
}

.task-wrapper {
  will-change: transform, left, top;
}

.task-wrapper:hover {
  will-change: transform, filter;
}

/* Enhanced Accessibility */
.island-header:focus {
  outline: 3px solid rgba(102, 126, 234, 0.6);
  outline-offset: 2px;
}

.smart-creation-fab:focus {
  outline: 3px solid rgba(255, 255, 255, 0.6);
  outline-offset: 3px;
}

/* Enhanced Responsive Design */
@media (max-width: 768px) {
  .island-header {
    padding: 12px 16px;
    max-height: 100px;
  }
  
  .island-title {
    font-size: 14px;
  }
  
  .island-count {
    font-size: 12px;
  }
  
  .keyword-tag {
    font-size: 10px;
    padding: 3px 6px;
  }
  
  .smart-creation-fab {
    padding: 14px 18px;
    font-size: 14px;
    min-width: 130px;
    bottom: 20px;
    right: 20px;
  }
  
  .fab-icon {
    font-size: 18px;
  }
  
  .fab-label {
    font-size: 12px;
  }
}

/* Enhanced Dark Mode Support */
@media (prefers-color-scheme: dark) {
  .sticky-canvas {
    background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
  }
  
  .canvas-grid {
    background-image: 
      linear-gradient(rgba(102, 126, 234, 0.2) 1px, transparent 1px),
      linear-gradient(90deg, rgba(102, 126, 234, 0.2) 1px, transparent 1px);
  }
  
  .canvas-grid::after {
    background-image: radial-gradient(circle, rgba(102, 126, 234, 0.3) 1px, transparent 1px);
  }
  
  .island-header {
    background: rgba(31, 41, 55, 0.95);
    border: 2px solid rgba(102, 126, 234, 0.4);
    color: #f9fafb;
  }
  
  .island-header:hover {
    background: rgba(31, 41, 55, 0.98);
    border-color: rgba(102, 126, 234, 0.6);
  }
  
  .island-name {
    color: #f9fafb;
  }
  
  .island-count {
    color: rgba(156, 163, 175, 0.8);
    background: rgba(102, 126, 234, 0.2);
    border: 1px solid rgba(102, 126, 234, 0.3);
  }
  
  .keyword-tag {
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
    color: rgba(102, 126, 234, 0.9);
    border: 1px solid rgba(102, 126, 234, 0.3);
  }
}
</style>